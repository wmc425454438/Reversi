<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>翻转棋</title>
    <link rel="stylesheet" href="css/chessboard.css">
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id="app">
        <table>
            <tbody>
                <tr v-for="(row, rowIndex) in tableArr" :index="rowIndex">
                    <td v-for="(col, colIndex) in row" :index="colIndex" v-on:click="moveChess(rowIndex, colIndex)">
                        <div class="element">
                            <div :class="{
                                'chess': true,
                                'chess-orange': col.type === 1, 
                                'chess-blue': col.type === 2,
                                'chess-movable': col.type === 3,
                                'chess-rotate': col.reversal,
                            }"></div>
                            <!-- <div v-if="col.type == 1" :class="{ chess: true, 'chess-orange': true, 'chess-rotate': col.reversal }"></div>
                            <div v-if="col.type == 2" :class="{ chess: true, 'chess-blue': true, 'chess-rotate': col.reversal }"></div>
                            <div v-if="col.type == 3" class="chess chess-movable"></div> -->
                        </div>
                    </td>
                </tr>
                <!-- <tr >
                    <td >
                        <div class="element">
                            <div class="chess chess_orange"></div>
                            <div class="chess chess_blue"></div>
                        </div>
                    </td>
                </tr> -->
            </tbody>
        </table>
        <button v-on:click="undoClick" v-if="undoStack.length > 1">悔棋</button>
        <!-- <button v-on:click="setChessTypeAction" >翻转</button> -->
    </div>
</body>
<script>
    // 点击下子
    // 上传github （今天）
    // 计算可下子区域
    // 计算翻转棋子(2.22)
    // 支持悔棋，方便调整状态，每一步推入栈

    // 增加翻转特效(2.22) 棋子对象属性？
    // 增加初始血量和基础攻击力棋子(需要引入对象概念) 重写棋子12的概念？

    // 血量为0判断失败
    // 增加特殊效果棋子
    // 增加正营
    // 增加棋子特效
    // 1橙色 2蓝色 3可以落子的位置
    function createArray(m,n){
      return new Array(m).fill('').map(d => {
        return new Array(n).fill('').map(o=> {
            return { type: 0, reversal: true, characters: {} }
        });
      });
    }
    var app = new Vue({
        el: "#app",
        data: {
            tableArr: null,
            tableColNum: 6,
            tableRowNum: 6,
            lastMove: 1,
            undoStack: [],
            reversiActive: true,
        },
        computed: {
        },
        created: function() {
            let tableArr = createArray(6,6);
            tableArr[2][2].type = 1;
            tableArr[2][3].type = 2;
            tableArr[3][2].type = 2;
            tableArr[3][3].type = 1;
            console.log(tableArr);
            this.tableArr = tableArr;
            this.calculateMovableArea(1);
            this.undoStack.push(JSON.parse(JSON.stringify(this.tableArr)));
        },
        methods: {
            undoClick: function() {
                let nowStep = this.undoStack.pop();
                let stackLen = this.undoStack.length;
                if (this.undoStack.length >= 1) {
                    this.tableArr = JSON.parse(JSON.stringify(this.undoStack[stackLen-1]));
                }
                this.lastMove = this.lastMove === 1 ? 2 : 1;
                this.$forceUpdate();
            },
            moveChess: function(row, col) {
                let { type } = this.tableArr[row][col];
                let nowMoveType = this.lastMove;
                if (type === 3) {
                    if(this.lastMove == 1) {
                        this.setChessTypeAction(row, col, { type: 1 });
                        this.lastMove = 2;
                    } else if(this.lastMove == 2) {
                        this.setChessTypeAction(row, col, { type: 2 });
                        this.lastMove = 1;
                    }
                    this.reversiChess(row, col, nowMoveType);
                    this.calculateMovableArea(this.lastMove);
                }
                this.undoStack.push(JSON.parse(JSON.stringify(this.tableArr)));
            },
            calculateMovableArea: function(nowMoveType) {
                let self = this;
                // 先清除之前的可下子区域
                self.clearMovableArea();
                // 现在的下子的是1还是2
                // 每一颗棋子的上下左右的尽头不是自己
                // 每一颗的斜边尽头不是自己
                // 满足8个方向的上述条件可下子
                // 先遍历每个棋子的位置，找到棋子相同类型棋子，再寻找可以落子的位置。
                let tableArr = this.tableArr;
                tableArr.map((row, rowIndex) => {
                    row.map((chess, colIndex) => {
                        if(chess.type === nowMoveType) {
                            // 找到当前已下的相同子
                            self.findCouldMoveArea(rowIndex, colIndex, nowMoveType);
                            console.log(rowIndex, colIndex);
                        }
                        return chess;
                    });
                    // tableArr[rowIndex][colIndex] = 3;
                    return row;
                });

            },
            clearMovableArea: function () {
                let self = this;
                let tableArr = self.tableArr;
                tableArr.map((row, rowIndex) => {
                    row.map((chess, colIndex) => {
                        if(chess.type === 3) {
                            self.setChessTypeAction(rowIndex, colIndex, { type: 0 })
                        }
                        return chess;
                    });
                    return row;
                });
            },
            findCouldMoveArea: function(row, col, chessType) {
                let self = this;
                let tableArr = self.tableArr;
                // 边界
                let colLen = self.tableColNum;
                let rowLen = self.tableRowNum;

                let enemyType = chessType === 1 ? 2 : 1;
             
                // 上下左右
                /**
                 * 向上找
                 * 是自己的子或直接false
                 * 不是自己的子继续向上找
                 * 是空位置返回true且不是临近的子且临界子不能为空
                 * 是边界返回false
                 */
                // col不变 row-1 判断边界情况>0
                // 上下左右判断方法一样，只是搜索规则不一样
                for(let i = row-1; i >= 0; i--) {
                    if(tableArr[i][col].type === chessType || tableArr[row-1][col].type === 0 || tableArr[row-1][col].type === 3) {
                        break;
                    } else if(tableArr[i][col].type === enemyType) {
                        continue;
                    } else {
                        tableArr[i][col].type = 3;
                        tableArr[i][col].reversal = false;
                        break;
                    }
                }
                for(let i = row+1; i <= rowLen-1; i++) {
                    if(tableArr[i][col].type === chessType || tableArr[row+1][col].type === 0 || tableArr[row+1][col].type === 3) {
                        break;
                    } else if(tableArr[i][col].type === enemyType) {
                        continue;
                    } else {
                        tableArr[i][col].type = 3;
                        tableArr[i][col].reversal = false;
                        break;
                    }
                }
                // 左
                for(let j = col-1; j >= 0; j--) {
                    if(tableArr[row][j].type === chessType || tableArr[row][col-1].type === 0 || tableArr[row][col-1].type === 3) {
                        break;
                    } else if(tableArr[row][j].type === enemyType) {
                        continue;
                    } else {
                        tableArr[row][j].type = 3;
                        tableArr[row][j].reversal = false;
                        break;
                    }
                }
                for(let j = col+1; j <= colLen-1; j++) {
                    if(tableArr[row][j].type === chessType || tableArr[row][col+1].type === 0 || tableArr[row][col+1].type === 3) {
                        break;
                    } else if(tableArr[row][j].type === enemyType) {
                        continue;
                    } else {
                        tableArr[row][j].type = 3;
                        tableArr[row][j].reversal = false;
                        break;
                    }
                }
                // 左上角
                for(let i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--) {
                    if(tableArr[i][j].type === chessType || tableArr[row-1][col-1].type === 0 || tableArr[row-1][col-1].type === 3) {
                        break;
                    } else if(tableArr[i][j].type === enemyType) {
                        continue;
                    } else {
                        tableArr[i][j].type = 3;
                        tableArr[i][j].reversal = false;
                        break;
                    }
                }
                // 右下角
                for(let i = row+1, j = col+1; i <= rowLen-1 && j <= colLen-1; i++, j++) {
                    if(tableArr[i][j].type === chessType || tableArr[row+1][col+1].type === 0 || tableArr[row+1][col+1].type === 3) {
                        break;
                    } else if(tableArr[i][j].type === enemyType) {
                        continue;
                    } else {
                        tableArr[i][j].type = 3;
                        tableArr[i][j].reversal = false;
                        break;
                    }
                }
                // 左下角
                for(let i = row+1, j = col-1; i <= rowLen-1 && j >= 0; i++, j--) {
                    if(tableArr[i][j].type === chessType || tableArr[row+1][col-1].type === 0 || tableArr[row+1][col-1].type === 3) {
                        break;
                    } else if(tableArr[i][j].type === enemyType) {
                        continue;
                    } else {
                        tableArr[i][j].type = 3;
                        tableArr[i][j].reversal = false;
                        break;
                    }
                }
                // 右上角
                for(let i = row-1, j = col+1; i >= 0 && j <= colLen-1; i--, j++) {
                    if(tableArr[i][j].type === chessType || tableArr[row-1][col+1].type === 0 || tableArr[row-1][col+1].type === 3) {
                        break;
                    } else if(tableArr[i][j].type === enemyType) {
                        continue;
                    } else {
                        tableArr[i][j].type = 3;
                        tableArr[i][j].reversal = false;
                        break;
                    }
                }

                this.$forceUpdate();
            },
            reversiChess: function(row, col, chessType) {
                // 当前下子的位置和当前下子的类型
                // 寻找当前下子类型相同的上下左右，中间有不同类型的子就翻转
                // 遇到空直接返回false
                // 为其他类型的子继续查找
                // 为相同类型的子就跳出，且翻转同一行或者同一列的子
                // 上
                let self = this;
                let tableArr = self.tableArr;
                // 边界
                let colLen = self.tableColNum;
                let rowLen = self.tableRowNum;

                let enemyType = chessType === 1 ? 2 : 1;
             
                // 上下左右
                /**
                 * 向上找
                 * 不是自己的子且连续则继续向上找
                 * 遇到是自己的子停止
                 * 是空位置直接break
                 * 是边界直接break
                 */
                // col不变 row-1 判断边界情况>0
                // 上下左右判断方法一样，只是搜索规则不一样
                for(let i = row-1; i >= 0; i--) {
                    if(tableArr[i][col].type === chessType && i !== row-1) {
                        // 寻找有效值和当前值的所有纵向的子，进行值的翻转
                        for(let _i = row-1; _i >= i; _i--) {
                            self.setChessTypeAction(_i, col, { type: chessType, reversal: true });
                        }
                        break;
                    } else if (tableArr[i][col].type === enemyType) {
                        continue;
                    } else {
                        break;
                    }
                }
                for(let i = row+1; i <= rowLen-1; i++) {
                    if(tableArr[i][col].type === chessType && i !== row+1) {
                        for(let _i = row+1; _i <= i; _i++) {
                            self.setChessTypeAction(_i, col, { type: chessType, reversal: true });
                        }
                        break;
                    } else if (tableArr[i][col].type === enemyType) {
                        continue;
                    } else {
                        break;
                    }
                }
                for(let j = col-1; j >= 0; j--) {
                    if(tableArr[row][j].type === chessType && j !== col-1) {
                        for(let _j = col-1; _j >= j; _j--) {
                            self.setChessTypeAction(row, _j, { type: chessType, reversal: true });
                        }
                        break;
                    } else if (tableArr[row][j].type === enemyType) {
                        continue;
                    } else {
                        break;
                    }
                }
                for(let j = col+1; j <= colLen-1; j++) {
                    if(tableArr[row][j].type === chessType && j !== col+1) {
                        for(let _j = col+1; _j <= j; _j++) {
                            self.setChessTypeAction(row, _j, { type: chessType, reversal: true });
                        }
                        break;
                    } else if (tableArr[row][j].type === enemyType) {
                        continue;
                    } else {
                        break;
                    }
                }
                for(let i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--) {
                    if(tableArr[i][j].type === chessType && i !== row-1 && j !== col-1) {
                        for(let _i = row-1, _j = col-1; _i >= i && _j >= j; _i--, _j--) {
                            self.setChessTypeAction(_i, _j, { type: chessType, reversal: true });
                        }
                        break;
                    } else if (tableArr[i][j].type === enemyType) {
                        continue;
                    } else {
                        break;
                    }
                }
                for(let i = row+1, j = col+1; i <= rowLen-1 && j <= colLen-1; i++, j++) {
                    if(tableArr[i][j].type === chessType && i !== row+1 && j !== col+1) {
                        for(let _i = row+1, _j = col+1; _i <= i && _j <= j; _i++, _j++) {
                            self.setChessTypeAction(_i, _j, { type: chessType, reversal: true });
                        }
                        break;
                    } else if (tableArr[i][j].type === enemyType) {
                        continue;
                    } else {
                        break;
                    }
                }
                // 左下角
                for(let i = row+1, j = col-1; i <= rowLen-1 && j >= 0; i++, j--) {
                    if(tableArr[i][j].type === chessType && i !== row+1 && j !== col-1) {
                        for(let _i = row+1, _j = col-1; _i <= i && _j >= j; _i++, _j--) {
                            self.setChessTypeAction(_i, _j, { type: chessType, reversal: true });
                        }
                        break;
                    } else if (tableArr[i][j].type === enemyType) {
                        continue;
                    } else {
                        break;
                    }
                }
                // 右上角
                for(let i = row-1, j = col+1; i >= 0 && j <= colLen-1; i--, j++) {
                    if(tableArr[i][j].type === chessType && i !== row-1 && j !== col+1) {
                        for(let _i = row-1, _j = col+1; _i >= i && _j <= j; _i--, _j++) {
                            self.setChessTypeAction(_i, _j, { type: chessType, reversal: true });
                        }
                        break;
                    } else if (tableArr[i][j].type === enemyType) {
                        continue;
                    } else {
                        break;
                    }
                }
            },
            setChessTypeAction: function(row, col, obj) {
                let self = this;
                // let { type = 0, reversal = false } = obj;
                let tableObj = self.tableArr[row][col];
                self.$set(self.tableArr[row], col, Object.assign(tableObj, obj));
            },
            
            reversiAnimation: function() {

            },
        },
        
    });
    
</script>
</html>